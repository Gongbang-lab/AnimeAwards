<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Jikan Full History Extractor v19</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { background: #0b0e14; color: #ecf0f1; font-family: 'Pretendard', sans-serif; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; background: #151f28; padding: 30px; border-radius: 15px; border: 1px solid #2e3c4a; }
        #log { background: #000; color: #00ffcc; height: 400px; overflow-y: auto; padding: 15px; font-family: monospace; font-size: 12px; border: 1px solid #2e3c4a; margin-bottom: 10px; }
        button { padding: 12px 20px; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; background: #00d1b2; color: #000; transition: 0.2s; }
        button:hover { opacity: 0.8; }
        .progress-bar { height: 8px; background: #2e3c4a; width: 100%; border-radius: 4px; margin: 10px 0; }
        #bar-fill { height: 100%; background: #00d1b2; width: 0%; transition: 0.3s; }
        textarea { width: 100%; height: 150px; background: #0b1622; color: #8ba3ad; border: 1px solid #2e3c4a; border-radius: 8px; padding: 10px; font-size: 11px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Full History Extractor v19</h1>
        <p style="color:#8ba3ad;">ë£¨í‚¤ ì „ì²´ í•„ëª¨ê·¸ë˜í”¼ & ì—°ë„(Year) ì •ë°€ ì¡°íšŒ ì‹œìŠ¤í…œ</p>
        <div class="controls">
            <button onclick="startExtraction()">ì „ì²´ ì´ë ¥ ì¶”ì¶œ ì‹œì‘</button>
            <button style="background:#f1c40f;" onclick="downloadJS()">JS ì €ì¥</button>
            <button id="img-btn" style="background:#e74c3c; color:#fff;" onclick="downloadAllImages()" disabled>ì´ë¯¸ì§€ ZIP</button>
        </div>
        <div class="progress-bar"><div id="bar-fill"></div></div>
        <div id="log">ì¤€ë¹„ ì™„ë£Œ. [ì „ì²´ ì´ë ¥ ì¶”ì¶œ ì‹œì‘]ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</div>
        <textarea id="output" readonly placeholder="ê²°ê³¼ JSONì´ ì—¬ê¸°ì— ìƒì„±ë©ë‹ˆë‹¤."></textarea>
    </div>

    <script>
        let rookieStore = {};
        let imageFiles = [];
        const THIS_YEAR = 2026;
        
        // [ìºì‹± ì‹œìŠ¤í…œ] ì´ë¯¸ ì¡°íšŒí•œ ì• ë‹ˆë©”ì´ì…˜ì˜ ì—°ë„ë¥¼ ì €ì¥í•´ API í˜¸ì¶œì„ ì•„ë‚Œ
        const animeYearCache = new Map(); 

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        function clean(str) { return str.replace(/[^ê°€-í£a-zA-Z0-9]/g, ''); }

        async function fetchSmart(url, retries = 3) {
            try {
                const res = await fetch(url);
                if (res.status === 429) { await sleep(2000); return fetchSmart(url, retries); }
                if (res.status >= 500) {
                    if (retries > 0) { await sleep(3000); return fetchSmart(url, retries - 1); }
                    else return null;
                }
                return await res.json();
            } catch (e) { return null; }
        }

        // ì• ë‹ˆë©”ì´ì…˜ ì—°ë„ ì¡°íšŒ í•¨ìˆ˜ (ìºì‹œ ì‚¬ìš©)
        async function getAnimeYear(animeId) {
            if (animeYearCache.has(animeId)) return animeYearCache.get(animeId);
            
            await sleep(600); // ìƒì„¸ ì¡°íšŒ ì†ë„ ì œí•œ
            const data = await fetchSmart(`https://api.jikan.moe/v4/anime/${animeId}`);
            const year = data?.data?.aired?.prop?.from?.year || 0; // 0ì€ ì—°ë„ ë¯¸ìƒ
            
            animeYearCache.set(animeId, year); // ìºì‹œì— ì €ì¥
            return year;
        }

        async function startExtraction() {
            const log = document.getElementById('log');
            const fill = document.getElementById('bar-fill');
            rookieStore = {}; imageFiles = [];
            let candidateMap = new Map();

            log.innerHTML = `ğŸ“¡ [1ë‹¨ê³„] ${THIS_YEAR}ë…„ í™œë™ ì„±ìš° ìŠ¤ìº” ì¤‘...<br>`;
            const seasons = ['winter', 'spring', 'summer', 'fall'];

            // 1. ì˜¬í•´ í™œë™ ì„±ìš° 1ì°¨ í•„í„°ë§
            for (let s of seasons) {
                const seasonData = await fetchSmart(`https://api.jikan.moe/v4/seasons/${THIS_YEAR}/${s}`);
                if (seasonData?.data) {
                    for (let anime of seasonData.data) {
                        const charData = await fetchSmart(`https://api.jikan.moe/v4/anime/${anime.mal_id}/characters`);
                        await sleep(800);
                        
                        if (charData?.data) {
                            charData.data.forEach(c => {
                                c.voice_actors?.forEach(va => {
                                    if (va.language === 'Japanese') {
                                        const vaId = va.person.mal_id;
                                        if (!candidateMap.has(vaId)) {
                                            candidateMap.set(vaId, { id: vaId, name: va.person.name, thisYearRoles: [] });
                                        }
                                        candidateMap.get(vaId).thisYearRoles.push(c.role); // Main, Supporting ì²´í¬ìš©
                                    }
                                });
                            });
                        }
                    }
                }
                log.innerHTML += `âœ… ${s} ì‹œì¦Œ ìŠ¤ìº” ì™„ë£Œ<br>`;
                log.scrollTop = log.scrollHeight;
            }

            // 2. ë¡œì»¬ í•„í„°ë§ (ì˜¬í•´ 2ì‘í’ˆ ì´ìƒ & ì£¼/ì¡°ì—° í¬í•¨)
            const allCandidates = Array.from(candidateMap.values());
            const survivors = allCandidates.filter(va => {
                const workCount = va.thisYearRoles.length;
                if (workCount < 2) return false;
                const hasMainSupport = va.thisYearRoles.some(r => r === 'Main' || r === 'Supporting');
                return hasMainSupport;
            });

            log.innerHTML += `ğŸ” í›„ë³´ ì••ì¶•: ${allCandidates.length}ëª… -> ${survivors.length}ëª…<br>`;
            log.innerHTML += `ğŸš€ [2ë‹¨ê³„] í›„ë³´ ì„±ìš° ì „ì²´ í•„ëª¨ê·¸ë˜í”¼ ì •ë°€ ì¡°íšŒ ì‹œì‘ (ì‹œê°„ì´ ê±¸ë¦½ë‹ˆë‹¤)...<br>`;

            // 3. ë£¨í‚¤ ê²€ì¦ ë° ì „ì²´ ì´ë ¥ ì¡°íšŒ
            for (let i = 0; i < survivors.length; i++) {
                fill.style.width = `${((i + 1) / survivors.length) * 100}%`;
                await analyzeFullHistory(survivors[i], log);
                await sleep(1000);
            }

            log.innerHTML += "âœ¨ ëª¨ë“  ì¶”ì¶œ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!";
            document.getElementById('img-btn').disabled = false;
            updateOutput();
        }

        async function analyzeFullHistory(va, log) {
            // ì „ì²´ ì¶œì—°ì‘ ê°€ì ¸ì˜¤ê¸°
            const voiceData = await fetchSmart(`https://api.jikan.moe/v4/people/${va.id}/voices`);
            if (!voiceData || !voiceData.data) return;

            // ë°°ê²½(Background) ì—­í•  ì œì™¸, ì£¼/ì¡°ì—°ë§Œ ë‚¨ê¸°ê¸° (ë°ì´í„° í’ˆì§ˆ ìœ„í•´)
            const allRoles = voiceData.data.filter(v => v.role !== 'Background');
            
            // ì¤‘ë³µ ì‘í’ˆ ì œê±°
            const uniqueWorks = new Map();
            allRoles.forEach(v => {
                if (!uniqueWorks.has(v.anime.mal_id)) uniqueWorks.set(v.anime.mal_id, v);
            });
            const workList = Array.from(uniqueWorks.values());

            // ë°ë·” ì—°ë„ í™•ì¸ (ê°€ì¥ IDê°€ ë‚®ì€ ì‘í’ˆì˜ ì—°ë„ ì¡°íšŒ)
            if (workList.length === 0) return;
            const firstWork = workList.reduce((p, c) => p.anime.mal_id < c.anime.mal_id ? p : c);
            const debutYear = await getAnimeYear(firstWork.anime.mal_id);
            
            const totalWorks = workList.length;
            const yearsActive = THIS_YEAR - debutYear;
            const thisYearCount = workList.filter(w => w.anime.mal_id > 55000).length; // ëŒ€ëµì  ì²´í¬

            let isRookie = false;
            // ë£¨í‚¤ ê¸°ì¤€ ê²€ì‚¬
            if (yearsActive <= 5 && totalWorks <= 30) isRookie = true;
            else if (yearsActive > 5 && va.thisYearRoles.length <= 5 && totalWorks <= 20) isRookie = true;

            if (isRookie) {
                log.innerHTML += `<span style="color:#00d1b2;">[RISING]</span> ${va.name} (ë°ë·”:${debutYear} / ì „ì²´:${totalWorks}ì‘) - ìƒì„¸ ì—°ë„ ì¡°íšŒ ì¤‘...<br>`;
                log.scrollTop = log.scrollHeight;

                // [ì¤‘ìš”] ë£¨í‚¤ë¡œ í™•ì •ëœ ê²½ìš°ì—ë§Œ ëª¨ë“  ì‘í’ˆì˜ ì—°ë„ë¥¼ ì¡°íšŒ (API ì ˆì•½)
                const fullHistory = [];
                
                // ìµœì‹ ìˆœ ì •ë ¬ì„ ìœ„í•´ ì—­ìˆœ í˜¹ì€ ì •ë ¬ ì²˜ë¦¬
                workList.sort((a, b) => b.anime.mal_id - a.anime.mal_id); 

                for (let work of workList) {
                    const y = await getAnimeYear(work.anime.mal_id);
                    const charName = work.character.name;
                    const fileName = `${clean(va.name)}${clean(charName)}.jpg`;

                    if (work.character.images?.jpg?.image_url) {
                        imageFiles.push({ url: work.character.images.jpg.image_url, name: fileName });
                    }

                    fullHistory.push({
                        animeTitle: work.anime.title,
                        year: y, // ì—°ë„ í•„ë“œ ì¶”ê°€
                        charName: charName,
                        charimg: `../image/rookiecv/${fileName}`
                    });
                }

                rookieStore[va.name] = {
                    name: va.name,
                    debutYear: debutYear,
                    cvimg: "", // ìˆ˜ë™ ì…ë ¥ìš© ë¹ˆ ê°’
                    characters: fullHistory
                };
            }
        }

        function updateOutput() { document.getElementById('output').value = "const RookieCVData = " + JSON.stringify(rookieStore, null, 2) + ";"; }
        function downloadJS() { saveAs(new Blob([document.getElementById('output').value], {type:'text/javascript'}), 'RookieCV.js'); }
        async function downloadAllImages() {
            const zip = new JSZip();
            // ì¤‘ë³µ ì´ë¯¸ì§€ ì œê±° í›„ ë‹¤ìš´ë¡œë“œ
            const uniqueImgs = new Map();
            imageFiles.forEach(i => uniqueImgs.set(i.name, i.url));
            
            const btn = document.getElementById('img-btn');
            btn.innerText = "ì••ì¶• ì¤‘...";
            
            for (let [name, url] of uniqueImgs) {
                try {
                    const res = await fetch(url);
                    const blob = await res.blob();
                    zip.file(name, blob);
                } catch (e) {}
            }
            zip.generateAsync({type:"blob"}).then(c => {
                saveAs(c, "full_history_images.zip");
                btn.innerText = "ì´ë¯¸ì§€ ZIP ì™„ë£Œ";
            });
        }
    </script>
</body>
</html>